{"version":3,"file":"static/chunks/4174-496df7018983053c.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+core@1.6.1/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+dom@1.6.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+react-dom@2.0.9_react-dom@18.2.0_react@18.2.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.2.0_react@18.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.2.0_react@18.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Floating/FloatingArrow/get-arrow-position-styles.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Floating/FloatingArrow/FloatingArrow.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Floating/get-floating-position/get-floating-position.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Floating/use-floating-auto-update.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Group/filter-falsy-children/filter-falsy-children.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Group/Group.module.css.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Group/Group.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Portal/Portal.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/Portal/OptionalPortal.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.context.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+hooks@7.9.0_react@18.2.0/node_modules/@mantine/hooks/esm/use-callback-ref/use-callback-ref.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/use-resize-observer.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaCorner/ScrollAreaCorner.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaRoot/ScrollAreaRoot.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+hooks@7.9.0_react@18.2.0/node_modules/@mantine/hooks/esm/use-debounced-callback/use-debounced-callback.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-ratio.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-size.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/linear-scale.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-thumb-offset-from-scroll.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/get-scroll-position-from-pointer.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/is-scrolling-within-scrollbar-bounds.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/to-int.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/compose-event-handlers.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.context.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/Scrollbar.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarX.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollbarY.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarVisible.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarAuto.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarHover.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbar.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/utils/add-unlinked-scroll-listener.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaThumb/ScrollAreaThumb.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollAreaViewport/ScrollAreaViewport.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.module.css.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/components/ScrollArea/ScrollArea.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/core/DirectionProvider/DirectionProvider.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/core/utils/create-safe-context/create-safe-context.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+core@7.9.0_@mantine+hooks@7.9.0_@types+react@18.2.51_react-dom@18.2.0_react@18.2.0/node_modules/@mantine/core/esm/core/utils/is-element/is-element.mjs","webpack://_N_E/./node_modules/.pnpm/@mantine+hooks@7.9.0_react@18.2.0/node_modules/@mantine/hooks/esm/use-merged-ref/use-merged-ref.mjs"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\nexport { arrow, useFloating };\n","import { isShadowRoot, isHTMLElement } from '@floating-ui/utils/dom';\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n\nexport { TYPEABLE_SELECTOR, activeElement, contains, getDocument, getPlatform, getTarget, getUserAgent, isAndroid, isEventTargetWithin, isJSDOM, isMac, isMouseLikePointerType, isReactEvent, isRootElement, isSafari, isTypeableCombobox, isTypeableElement, isVirtualClick, isVirtualPointerEvent, stopEvent };\n","import * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { stopEvent, getDocument, isMouseLikePointerType, contains, activeElement, isSafari, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, getTarget, getPlatform, isTypeableElement, isReactEvent, isRootElement, isEventTargetWithin, isMac, getUserAgent } from '@floating-ui/react/utils';\nimport { floor } from '@floating-ui/utils';\nimport { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';\nimport { tabbable, isTabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n  ...React\n};\n\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      return firstCellIndex + sizes[index].width - 1;\n    case 'bl':\n      return firstCellIndex + (sizes[index].height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/React.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(props) {\n  const {\n    children,\n    elementsRef,\n    labelsRef\n  } = props;\n  const [map, setMap] = React.useState(() => new Map());\n  const register = React.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = React.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(FloatingListContext.Provider, {\n    value: React.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    label\n  } = props;\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = React.useContext(FloatingListContext);\n  const [index$1, setIndex] = React.useState(null);\n  const componentRef = React.useRef(null);\n  const ref = React.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return React.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/React.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/React.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/React.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arent part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/React.forwardRef(function Composite(props, forwardedRef) {\n  const {\n    render,\n    orientation = 'both',\n    loop = true,\n    cols = 1,\n    disabledIndices = [],\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    itemSizes,\n    dense = false,\n    ...domProps\n  } = props;\n  const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = React.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = React.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n      nextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')\n      })]; // navigated cell will never be nullish\n    }\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      domProps.onKeyDown == null || domProps.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/React.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(props, forwardedRef) {\n  const {\n    render,\n    ...domProps\n  } = props;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = React.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      domProps.onFocus == null || domProps.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => // Ensure the id is unique with multiple independent versions of Floating UI\n// on <React 18\n\"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    serverHandoffComplete = true;\n  }, []);\n  return id;\n}\nconst useReactId = SafeReact.useId;\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\nlet devMessageSet;\nif (process.env.NODE_ENV !== \"production\") {\n  devMessageSet = /*#__PURE__*/new Set();\n}\nfunction warn() {\n  var _devMessageSet;\n  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n    messages[_key] = arguments[_key];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n    console.warn(message);\n  }\n}\nfunction error() {\n  var _devMessageSet3;\n  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    messages[_key2] = arguments[_key2];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n    console.error(message);\n  }\n}\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(props, ref) {\n  const {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      warn('The `ref` prop is required for `FloatingArrow`.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  const computedStrokeWidth = strokeWidth * 2;\n  const halfStrokeWidth = computedStrokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + computedStrokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), computedStrokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: computedStrokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + computedStrokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(props) {\n  const {\n    children,\n    id\n  } = props;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(props) {\n  const {\n    children\n  } = props;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef(-1);\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef(-1);\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = window.setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          function handleMouseMove() {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }\n          if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {\n            return;\n          }\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          if (pointerTypeRef.current === 'touch') {\n            handleMouseMove();\n          } else {\n            restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);\n          }\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, mouseOnly, open, restMs, onOpenChange, closeWithDelay]);\n}\n\nconst NOOP = () => {};\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: NOOP,\n  setState: NOOP,\n  isInstantPhase: false\n});\n\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction FloatingDelayGroup(props) {\n  const {\n    children,\n    delay,\n    timeoutMs = 0\n  } = props;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction useDelayGroup(context, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    floatingId\n  } = context;\n  const {\n    id: optionId\n  } = options;\n  const id = optionId != null ? optionId : floatingId;\n  const groupContext = useDelayGroupContext();\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = groupContext;\n  index(() => {\n    if (!currentId) return;\n    setState({\n      delay: {\n        open: 1,\n        close: getDelay(initialDelay, 'close')\n      }\n    });\n    if (currentId !== id) {\n      onOpenChange(false);\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!currentId) return;\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (setCurrentId === NOOP || !open) return;\n    setCurrentId(id);\n  }, [open, setCurrentId, id]);\n  return groupContext;\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = getDocument(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    id,\n    root\n  } = props;\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const [portalNode, setPortalNode] = React.useState(null);\n  const portalNodeRef = React.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !isElement(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(props) {\n  const {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = props;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  let tabbableEl = element;\n  if (!tabbableEl || getNodeName(tabbableEl) === 'body') return;\n  if (!isTabbable(tabbableEl, getTabbableOptions())) {\n    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];\n    if (tabbableChild) {\n      tabbableEl = tabbableChild;\n    }\n  }\n  previouslyFocusedElements.push(tabbableEl);\n  if (previouslyFocusedElements.length > LIST_LIMIT) {\n    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    let openEvent = contextData.openEvent;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        open,\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (open) {\n        openEvent = event;\n      }\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = activeElement(doc);\n      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored  leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst activeLocks = /*#__PURE__*/new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(props, ref) {\n  const {\n    lockScroll = false,\n    ...rest\n  } = props;\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  const didKeyDownRef = React.useRef(false);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const endedOrStartedInsideRef = React.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = getDocument(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = isElement(target) ? target : null;\n    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n      const nextParent = getParentNode(targetRootAncestor);\n      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && isElement(target) && !isRootElement(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !contains(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const [_domReference, setDomReference] = React.useState(null);\n  const [positionReference, _setPositionReference] = React.useState(null);\n  const optionDomReference = (_options$elements = options.elements) == null ? void 0 : _options$elements.reference;\n  const domReference = optionDomReference || _domReference;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (optionDomReference && !isElement(optionDomReference)) {\n      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');\n    }\n  }\n  index(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = useFloating$1({\n    ...options,\n    elements: {\n      ...options.elements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    dataRef.current.openEvent = open ? event : undefined;\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = React.useCallback(node => {\n    const computedPositionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    _setPositionReference(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  const keyboardModalityRef = React.useRef(true);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = getWindow(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if (isVirtualPointerEvent(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = getTarget(event.nativeEvent);\n          if (visibleOnly && isElement(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if (isSafari() && isMac()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !isTypeableElement(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = activeElement(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            // We can not rely on relatedTarget to point to the correct element\n            // as it will only point to the shadow host of the newly focused element\n            // and not the element that actually has received focus if it is located\n            // inside a shadow root.\n            if (contains(refs.floating.current, activeEl) || contains(domReference, activeEl) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\n\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const [virtualId, setVirtualId] = React.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = activeElement(getDocument(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if (isHTMLElement(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n        indexRef.current = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl'),\n          stopEvent: true\n        })]; // navigated cell will never be nullish\n\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  stopEvent(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  stopEvent(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(!isTypeableCombobox(domReference) && ariaActiveDescendantProp),\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined,\n        ...(ariaRole === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(ariaRole === 'menu' && {\n          id: referenceId\n        }),\n        ...(ariaRole === 'menu' && isNested && {\n          role: 'menuitem'\n        }),\n        ...(role === 'select' && {\n          'aria-autocomplete': 'none'\n        }),\n        ...(role === 'combobox' && {\n          'aria-autocomplete': 'list'\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(ariaRole === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      },\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = {\n          role: 'option',\n          ...(active && {\n            id: floatingId + \"-option\"\n          })\n        };\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return {\n              ...commonProps,\n              'aria-selected': active && selected\n            };\n          case 'combobox':\n            {\n              return {\n                ...commonProps,\n                ...(active && {\n                  'aria-selected': true\n                })\n              };\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setInitiated(true);\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        warn('`placement` side must be \"bottom\" when using the `inner`', 'middleware.');\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nexport { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","'use client';\nimport { rem } from '../../../core/utils/units-converters/rem.mjs';\nimport 'react';\nimport 'react/jsx-runtime';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\n\nfunction horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {\n  if (placement === \"center\" || arrowPosition === \"center\") {\n    return { top: arrowY };\n  }\n  if (placement === \"end\") {\n    return { bottom: arrowOffset };\n  }\n  if (placement === \"start\") {\n    return { top: arrowOffset };\n  }\n  return {};\n}\nfunction verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {\n  if (placement === \"center\" || arrowPosition === \"center\") {\n    return { left: arrowX };\n  }\n  if (placement === \"end\") {\n    return { [dir === \"ltr\" ? \"right\" : \"left\"]: arrowOffset };\n  }\n  if (placement === \"start\") {\n    return { [dir === \"ltr\" ? \"left\" : \"right\"]: arrowOffset };\n  }\n  return {};\n}\nconst radiusByFloatingSide = {\n  bottom: \"borderTopLeftRadius\",\n  left: \"borderTopRightRadius\",\n  right: \"borderBottomLeftRadius\",\n  top: \"borderBottomRightRadius\"\n};\nfunction getArrowPositionStyles({\n  position,\n  arrowSize,\n  arrowOffset,\n  arrowRadius,\n  arrowPosition,\n  arrowX,\n  arrowY,\n  dir\n}) {\n  const [side, placement = \"center\"] = position.split(\"-\");\n  const baseStyles = {\n    width: rem(arrowSize),\n    height: rem(arrowSize),\n    transform: \"rotate(45deg)\",\n    position: \"absolute\",\n    [radiusByFloatingSide[side]]: rem(arrowRadius)\n  };\n  const arrowPlacement = rem(-arrowSize / 2);\n  if (side === \"left\") {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      right: arrowPlacement,\n      borderLeftColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    };\n  }\n  if (side === \"right\") {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      left: arrowPlacement,\n      borderRightColor: \"transparent\",\n      borderTopColor: \"transparent\"\n    };\n  }\n  if (side === \"top\") {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      bottom: arrowPlacement,\n      borderTopColor: \"transparent\",\n      borderLeftColor: \"transparent\"\n    };\n  }\n  if (side === \"bottom\") {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      top: arrowPlacement,\n      borderBottomColor: \"transparent\",\n      borderRightColor: \"transparent\"\n    };\n  }\n  return {};\n}\n\nexport { getArrowPositionStyles };\n//# sourceMappingURL=get-arrow-position-styles.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef } from 'react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../../core/Box/Box.mjs';\nimport { useDirection } from '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { getArrowPositionStyles } from './get-arrow-position-styles.mjs';\n\nconst FloatingArrow = forwardRef(\n  ({\n    position,\n    arrowSize,\n    arrowOffset,\n    arrowRadius,\n    arrowPosition,\n    visible,\n    arrowX,\n    arrowY,\n    style,\n    ...others\n  }, ref) => {\n    const { dir } = useDirection();\n    if (!visible) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(\n      \"div\",\n      {\n        ...others,\n        ref,\n        style: {\n          ...style,\n          ...getArrowPositionStyles({\n            position,\n            arrowSize,\n            arrowOffset,\n            arrowRadius,\n            arrowPosition,\n            dir,\n            arrowX,\n            arrowY\n          })\n        }\n      }\n    );\n  }\n);\nFloatingArrow.displayName = \"@mantine/core/FloatingArrow\";\n\nexport { FloatingArrow };\n//# sourceMappingURL=FloatingArrow.mjs.map\n","'use client';\nfunction getFloatingPosition(dir, position) {\n  if (dir === \"rtl\" && (position.includes(\"right\") || position.includes(\"left\"))) {\n    const [side, placement] = position.split(\"-\");\n    const flippedPosition = side === \"right\" ? \"left\" : \"right\";\n    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;\n  }\n  return position;\n}\n\nexport { getFloatingPosition };\n//# sourceMappingURL=get-floating-position.mjs.map\n","'use client';\nimport { useState, useEffect } from 'react';\nimport { autoUpdate } from '@floating-ui/react';\nimport { useDidUpdate } from '@mantine/hooks';\n\nfunction useFloatingAutoUpdate({\n  opened,\n  floating,\n  position,\n  positionDependencies\n}) {\n  const [delayedUpdate, setDelayedUpdate] = useState(0);\n  useEffect(() => {\n    if (floating.refs.reference.current && floating.refs.floating.current) {\n      return autoUpdate(\n        floating.refs.reference.current,\n        floating.refs.floating.current,\n        floating.update\n      );\n    }\n    return void 0;\n  }, [\n    floating.refs.reference.current,\n    floating.refs.floating.current,\n    opened,\n    delayedUpdate,\n    position\n  ]);\n  useDidUpdate(() => {\n    floating.update();\n  }, positionDependencies);\n  useDidUpdate(() => {\n    setDelayedUpdate((c) => c + 1);\n  }, [opened]);\n}\n\nexport { useFloatingAutoUpdate };\n//# sourceMappingURL=use-floating-auto-update.mjs.map\n","'use client';\nimport { Children } from 'react';\n\nfunction filterFalsyChildren(children) {\n  return Children.toArray(children).filter(Boolean);\n}\n\nexport { filterFalsyChildren };\n//# sourceMappingURL=filter-falsy-children.mjs.map\n","'use client';\nvar classes = {\"root\":\"m_4081bf90\"};\n\nexport { classes as default };\n//# sourceMappingURL=Group.module.css.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport 'react';\nimport { getSpacing } from '../../core/utils/get-size/get-size.mjs';\nimport '@mantine/hooks';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport { Box } from '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { filterFalsyChildren } from './filter-falsy-children/filter-falsy-children.mjs';\nimport classes from './Group.module.css.mjs';\n\nconst defaultProps = {\n  preventGrowOverflow: true,\n  gap: \"md\",\n  align: \"center\",\n  justify: \"flex-start\",\n  wrap: \"wrap\"\n};\nconst varsResolver = createVarsResolver(\n  (_, { grow, preventGrowOverflow, gap, align, justify, wrap }, { childWidth }) => ({\n    root: {\n      \"--group-child-width\": grow && preventGrowOverflow ? childWidth : void 0,\n      \"--group-gap\": getSpacing(gap),\n      \"--group-align\": align,\n      \"--group-justify\": justify,\n      \"--group-wrap\": wrap\n    }\n  })\n);\nconst Group = factory((_props, ref) => {\n  const props = useProps(\"Group\", defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    children,\n    gap,\n    align,\n    justify,\n    wrap,\n    grow,\n    preventGrowOverflow,\n    vars,\n    variant,\n    __size,\n    mod,\n    ...others\n  } = props;\n  const filteredChildren = filterFalsyChildren(children);\n  const childrenCount = filteredChildren.length;\n  const resolvedGap = getSpacing(gap ?? \"md\");\n  const childWidth = `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))`;\n  const stylesCtx = { childWidth };\n  const getStyles = useStyles({\n    name: \"Group\",\n    props,\n    stylesCtx,\n    className,\n    style,\n    classes,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver\n  });\n  return /* @__PURE__ */ jsx(\n    Box,\n    {\n      ...getStyles(\"root\"),\n      ref,\n      variant,\n      mod: [{ grow }, mod],\n      size: __size,\n      ...others,\n      children: filteredChildren\n    }\n  );\n});\nGroup.classes = classes;\nGroup.displayName = \"@mantine/core/Group\";\n\nexport { Group };\n//# sourceMappingURL=Group.mjs.map\n","'use client';\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { forwardRef, useState, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { useIsomorphicEffect, assignRef } from '@mantine/hooks';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../core/Box/Box.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\n\nfunction createPortalNode(props) {\n  const node = document.createElement(\"div\");\n  node.setAttribute(\"data-portal\", \"true\");\n  typeof props.className === \"string\" && node.classList.add(...props.className.split(\" \").filter(Boolean));\n  typeof props.style === \"object\" && Object.assign(node.style, props.style);\n  typeof props.id === \"string\" && node.setAttribute(\"id\", props.id);\n  return node;\n}\nconst defaultProps = {};\nconst Portal = forwardRef((props, ref) => {\n  const { children, target, ...others } = useProps(\"Portal\", defaultProps, props);\n  const [mounted, setMounted] = useState(false);\n  const nodeRef = useRef(null);\n  useIsomorphicEffect(() => {\n    setMounted(true);\n    nodeRef.current = !target ? createPortalNode(others) : typeof target === \"string\" ? document.querySelector(target) : target;\n    assignRef(ref, nodeRef.current);\n    if (!target && nodeRef.current) {\n      document.body.appendChild(nodeRef.current);\n    }\n    return () => {\n      if (!target && nodeRef.current) {\n        document.body.removeChild(nodeRef.current);\n      }\n    };\n  }, [target]);\n  if (!mounted || !nodeRef.current) {\n    return null;\n  }\n  return createPortal(/* @__PURE__ */ jsx(Fragment, { children }), nodeRef.current);\n});\nPortal.displayName = \"@mantine/core/Portal\";\n\nexport { Portal };\n//# sourceMappingURL=Portal.mjs.map\n","'use client';\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { Portal } from './Portal.mjs';\n\nfunction OptionalPortal({ withinPortal = true, children, ...others }) {\n  if (withinPortal) {\n    return /* @__PURE__ */ jsx(Portal, { ...others, children });\n  }\n  return /* @__PURE__ */ jsx(Fragment, { children });\n}\nOptionalPortal.displayName = \"@mantine/core/OptionalPortal\";\n\nexport { OptionalPortal };\n//# sourceMappingURL=OptionalPortal.mjs.map\n","'use client';\nimport 'react';\nimport { createSafeContext } from '../../core/utils/create-safe-context/create-safe-context.mjs';\nimport 'react/jsx-runtime';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../core/Box/Box.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\n\nconst [ScrollAreaProvider, useScrollAreaContext] = createSafeContext(\n  \"ScrollArea.Root component was not found in tree\"\n);\n\nexport { ScrollAreaProvider, useScrollAreaContext };\n//# sourceMappingURL=ScrollArea.context.mjs.map\n","'use client';\nimport { useRef, useEffect, useMemo } from 'react';\n\nfunction useCallbackRef(callback) {\n  const callbackRef = useRef(callback);\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n  return useMemo(() => (...args) => callbackRef.current?.(...args), []);\n}\n\nexport { useCallbackRef };\n//# sourceMappingURL=use-callback-ref.mjs.map\n","'use client';\nimport { useCallbackRef, useIsomorphicEffect } from '@mantine/hooks';\n\nfunction useResizeObserver(element, onResize) {\n  const handleResize = useCallbackRef(onResize);\n  useIsomorphicEffect(() => {\n    let rAF = 0;\n    if (element) {\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n    return void 0;\n  }, [element, handleResize]);\n}\n\nexport { useResizeObserver };\n//# sourceMappingURL=use-resize-observer.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState } from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { useResizeObserver } from '../use-resize-observer.mjs';\n\nconst Corner = forwardRef((props, ref) => {\n  const { style, ...others } = props;\n  const ctx = useScrollAreaContext();\n  const [width, setWidth] = useState(0);\n  const [height, setHeight] = useState(0);\n  const hasSize = Boolean(width && height);\n  useResizeObserver(ctx.scrollbarX, () => {\n    const h = ctx.scrollbarX?.offsetHeight || 0;\n    ctx.onCornerHeightChange(h);\n    setHeight(h);\n  });\n  useResizeObserver(ctx.scrollbarY, () => {\n    const w = ctx.scrollbarY?.offsetWidth || 0;\n    ctx.onCornerWidthChange(w);\n    setWidth(w);\n  });\n  return hasSize ? /* @__PURE__ */ jsx(\"div\", { ...others, ref, style: { ...style, width, height } }) : null;\n});\nconst ScrollAreaCorner = forwardRef((props, ref) => {\n  const ctx = useScrollAreaContext();\n  const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);\n  const hasCorner = ctx.type !== \"scroll\" && hasBothScrollbarsVisible;\n  return hasCorner ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;\n});\n\nexport { Corner, ScrollAreaCorner };\n//# sourceMappingURL=ScrollAreaCorner.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport { Box } from '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { ScrollAreaProvider } from '../ScrollArea.context.mjs';\n\nconst defaultProps = {\n  scrollHideDelay: 1e3,\n  type: \"hover\"\n};\nconst ScrollAreaRoot = forwardRef((_props, ref) => {\n  const props = useProps(\"ScrollAreaRoot\", defaultProps, _props);\n  const { type, scrollHideDelay, scrollbars, ...others } = props;\n  const [scrollArea, setScrollArea] = useState(null);\n  const [viewport, setViewport] = useState(null);\n  const [content, setContent] = useState(null);\n  const [scrollbarX, setScrollbarX] = useState(null);\n  const [scrollbarY, setScrollbarY] = useState(null);\n  const [cornerWidth, setCornerWidth] = useState(0);\n  const [cornerHeight, setCornerHeight] = useState(0);\n  const [scrollbarXEnabled, setScrollbarXEnabled] = useState(false);\n  const [scrollbarYEnabled, setScrollbarYEnabled] = useState(false);\n  const rootRef = useMergedRef(ref, (node) => setScrollArea(node));\n  return /* @__PURE__ */ jsx(\n    ScrollAreaProvider,\n    {\n      value: {\n        type,\n        scrollHideDelay,\n        scrollArea,\n        viewport,\n        onViewportChange: setViewport,\n        content,\n        onContentChange: setContent,\n        scrollbarX,\n        onScrollbarXChange: setScrollbarX,\n        scrollbarXEnabled,\n        onScrollbarXEnabledChange: setScrollbarXEnabled,\n        scrollbarY,\n        onScrollbarYChange: setScrollbarY,\n        scrollbarYEnabled,\n        onScrollbarYEnabledChange: setScrollbarYEnabled,\n        onCornerWidthChange: setCornerWidth,\n        onCornerHeightChange: setCornerHeight\n      },\n      children: /* @__PURE__ */ jsx(\n        Box,\n        {\n          ...others,\n          ref: rootRef,\n          __vars: {\n            \"--sa-corner-width\": scrollbars !== \"xy\" ? \"0px\" : `${cornerWidth}px`,\n            \"--sa-corner-height\": scrollbars !== \"xy\" ? \"0px\" : `${cornerHeight}px`\n          }\n        }\n      )\n    }\n  );\n});\nScrollAreaRoot.displayName = \"@mantine/core/ScrollAreaRoot\";\n\nexport { ScrollAreaRoot };\n//# sourceMappingURL=ScrollAreaRoot.mjs.map\n","'use client';\nimport { useRef, useEffect, useCallback } from 'react';\nimport { useCallbackRef } from '../use-callback-ref/use-callback-ref.mjs';\n\nfunction useDebouncedCallback(callback, delay) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n  useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return useCallback(\n    (...args) => {\n      window.clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = window.setTimeout(() => handleCallback(...args), delay);\n    },\n    [handleCallback, delay]\n  );\n}\n\nexport { useDebouncedCallback };\n//# sourceMappingURL=use-debounced-callback.mjs.map\n","'use client';\nfunction getThumbRatio(viewportSize, contentSize) {\n  const ratio = viewportSize / contentSize;\n  return Number.isNaN(ratio) ? 0 : ratio;\n}\n\nexport { getThumbRatio };\n//# sourceMappingURL=get-thumb-ratio.mjs.map\n","'use client';\nimport { getThumbRatio } from './get-thumb-ratio.mjs';\n\nfunction getThumbSize(sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  return Math.max(thumbSize, 18);\n}\n\nexport { getThumbSize };\n//# sourceMappingURL=get-thumb-size.mjs.map\n","'use client';\nfunction linearScale(input, output) {\n  return (value) => {\n    if (input[0] === input[1] || output[0] === output[1])\n      return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nexport { linearScale };\n//# sourceMappingURL=linear-scale.mjs.map\n","'use client';\nimport { getThumbSize } from './get-thumb-size.mjs';\nimport { linearScale } from './linear-scale.mjs';\n\nfunction clamp(value, [min, max]) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction getThumbOffsetFromScroll(scrollPos, sizes, dir = \"ltr\") {\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === \"ltr\" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n\nexport { getThumbOffsetFromScroll };\n//# sourceMappingURL=get-thumb-offset-from-scroll.mjs.map\n","'use client';\nimport { getThumbSize } from './get-thumb-size.mjs';\nimport { linearScale } from './linear-scale.mjs';\n\nfunction getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = \"ltr\") {\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === \"ltr\" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);\n  return interpolate(pointerPos);\n}\n\nexport { getScrollPositionFromPointer };\n//# sourceMappingURL=get-scroll-position-from-pointer.mjs.map\n","'use client';\nfunction isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n\nexport { isScrollingWithinScrollbarBounds };\n//# sourceMappingURL=is-scrolling-within-scrollbar-bounds.mjs.map\n","'use client';\nfunction toInt(value) {\n  return value ? parseInt(value, 10) : 0;\n}\n\nexport { toInt };\n//# sourceMappingURL=to-int.mjs.map\n","'use client';\nfunction composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {\n  return (event) => {\n    originalEventHandler?.(event);\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n//# sourceMappingURL=compose-event-handlers.mjs.map\n","'use client';\nimport 'react';\nimport { createSafeContext } from '../../../core/utils/create-safe-context/create-safe-context.mjs';\nimport 'react/jsx-runtime';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\n\nconst [ScrollbarProvider, useScrollbarContext] = createSafeContext(\n  \"ScrollAreaScrollbar was not found in tree\"\n);\n\nexport { ScrollbarProvider, useScrollbarContext };\n//# sourceMappingURL=Scrollbar.context.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useRef, useEffect } from 'react';\nimport { useMergedRef, useCallbackRef, useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { useResizeObserver } from '../use-resize-observer.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { ScrollbarProvider } from './Scrollbar.context.mjs';\n\nconst Scrollbar = forwardRef((props, forwardedRef) => {\n  const {\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const [scrollbar, setScrollbar] = useState(null);\n  const composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node));\n  const rectRef = useRef(null);\n  const prevWebkitUserSelectRef = useRef(\"\");\n  const { viewport } = context;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebouncedCallback(onResize, 10);\n  const handleDragScroll = (event) => {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({ x, y });\n    }\n  };\n  useEffect(() => {\n    const handleWheel = (event) => {\n      const element = event.target;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel)\n        handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () => document.removeEventListener(\"wheel\", handleWheel, { passive: false });\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n  useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n  return /* @__PURE__ */ jsx(\n    ScrollbarProvider,\n    {\n      value: {\n        scrollbar,\n        hasThumb,\n        onThumbChange: useCallbackRef(onThumbChange),\n        onThumbPointerUp: useCallbackRef(onThumbPointerUp),\n        onThumbPositionChange: handleThumbPositionChange,\n        onThumbPointerDown: useCallbackRef(onThumbPointerDown)\n      },\n      children: /* @__PURE__ */ jsx(\n        \"div\",\n        {\n          ...scrollbarProps,\n          ref: composeRefs,\n          style: { position: \"absolute\", ...scrollbarProps.style },\n          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {\n            const mainPointer = 0;\n            if (event.button === mainPointer) {\n              const element = event.target;\n              element.setPointerCapture(event.pointerId);\n              rectRef.current = scrollbar.getBoundingClientRect();\n              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n              document.body.style.webkitUserSelect = \"none\";\n              handleDragScroll(event);\n            }\n          }),\n          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),\n          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {\n            const element = event.target;\n            if (element.hasPointerCapture(event.pointerId)) {\n              element.releasePointerCapture(event.pointerId);\n            }\n            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n            rectRef.current = null;\n          })\n        }\n      )\n    }\n  );\n});\n\nexport { Scrollbar };\n//# sourceMappingURL=Scrollbar.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useRef, useEffect } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { isScrollingWithinScrollbarBounds } from '../utils/is-scrolling-within-scrollbar-bounds.mjs';\nimport { getThumbSize } from '../utils/get-thumb-size.mjs';\nimport { toInt } from '../utils/to-int.mjs';\nimport { Scrollbar } from './Scrollbar.mjs';\n\nconst ScrollAreaScrollbarX = forwardRef(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const ctx = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = useState();\n    const ref = useRef(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);\n    useEffect(() => {\n      if (ref.current)\n        setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n    return /* @__PURE__ */ jsx(\n      Scrollbar,\n      {\n        \"data-orientation\": \"horizontal\",\n        ...others,\n        ref: composeRefs,\n        sizes,\n        style: {\n          ...style,\n          [\"--sa-thumb-width\"]: `${getThumbSize(sizes)}px`\n        },\n        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),\n        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),\n        onWheelScroll: (event, maxScrollPos) => {\n          if (ctx.viewport) {\n            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        },\n        onResize: () => {\n          if (ref.current && ctx.viewport && computedStyle) {\n            onSizesChange({\n              content: ctx.viewport.scrollWidth,\n              viewport: ctx.viewport.offsetWidth,\n              scrollbar: {\n                size: ref.current.clientWidth,\n                paddingStart: toInt(computedStyle.paddingLeft),\n                paddingEnd: toInt(computedStyle.paddingRight)\n              }\n            });\n          }\n        }\n      }\n    );\n  }\n);\n\nexport { ScrollAreaScrollbarX };\n//# sourceMappingURL=ScrollbarX.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useRef, useEffect } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { isScrollingWithinScrollbarBounds } from '../utils/is-scrolling-within-scrollbar-bounds.mjs';\nimport { getThumbSize } from '../utils/get-thumb-size.mjs';\nimport { toInt } from '../utils/to-int.mjs';\nimport { Scrollbar } from './Scrollbar.mjs';\n\nconst ScrollAreaScrollbarY = forwardRef(\n  (props, forwardedRef) => {\n    const { sizes, onSizesChange, style, ...others } = props;\n    const context = useScrollAreaContext();\n    const [computedStyle, setComputedStyle] = useState();\n    const ref = useRef(null);\n    const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);\n    useEffect(() => {\n      if (ref.current)\n        setComputedStyle(getComputedStyle(ref.current));\n    }, [ref]);\n    return /* @__PURE__ */ jsx(\n      Scrollbar,\n      {\n        ...others,\n        \"data-orientation\": \"vertical\",\n        ref: composeRefs,\n        sizes,\n        style: {\n          [\"--sa-thumb-height\"]: `${getThumbSize(sizes)}px`,\n          ...style\n        },\n        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),\n        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),\n        onWheelScroll: (event, maxScrollPos) => {\n          if (context.viewport) {\n            const scrollPos = context.viewport.scrollTop + event.deltaY;\n            props.onWheelScroll(scrollPos);\n            if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n              event.preventDefault();\n            }\n          }\n        },\n        onResize: () => {\n          if (ref.current && context.viewport && computedStyle) {\n            onSizesChange({\n              content: context.viewport.scrollHeight,\n              viewport: context.viewport.offsetHeight,\n              scrollbar: {\n                size: ref.current.clientHeight,\n                paddingStart: toInt(computedStyle.paddingTop),\n                paddingEnd: toInt(computedStyle.paddingBottom)\n              }\n            });\n          }\n        }\n      }\n    );\n  }\n);\n\nexport { ScrollAreaScrollbarY };\n//# sourceMappingURL=ScrollbarY.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useRef, useState } from 'react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../../core/Box/Box.mjs';\nimport { useDirection } from '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { getThumbRatio } from '../utils/get-thumb-ratio.mjs';\nimport { getThumbOffsetFromScroll } from '../utils/get-thumb-offset-from-scroll.mjs';\nimport { getScrollPositionFromPointer } from '../utils/get-scroll-position-from-pointer.mjs';\nimport { ScrollAreaScrollbarX } from './ScrollbarX.mjs';\nimport { ScrollAreaScrollbarY } from './ScrollbarY.mjs';\n\nconst ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {\n  const { orientation = \"vertical\", ...scrollbarProps } = props;\n  const { dir } = useDirection();\n  const context = useScrollAreaContext();\n  const thumbRef = useRef(null);\n  const pointerOffsetRef = useRef(0);\n  const [sizes, setSizes] = useState({\n    content: 0,\n    viewport: 0,\n    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n  const commonProps = {\n    ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: (thumb) => {\n      thumbRef.current = thumb;\n    },\n    onThumbPointerUp: () => {\n      pointerOffsetRef.current = 0;\n    },\n    onThumbPointerDown: (pointerPos) => {\n      pointerOffsetRef.current = pointerPos;\n    }\n  };\n  const getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);\n  if (orientation === \"horizontal\") {\n    return /* @__PURE__ */ jsx(\n      ScrollAreaScrollbarX,\n      {\n        ...commonProps,\n        ref: forwardedRef,\n        onThumbPositionChange: () => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollLeft;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes, dir);\n            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n          }\n        },\n        onWheelScroll: (scrollPos) => {\n          if (context.viewport)\n            context.viewport.scrollLeft = scrollPos;\n        },\n        onDragScroll: (pointerPos) => {\n          if (context.viewport) {\n            context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);\n          }\n        }\n      }\n    );\n  }\n  if (orientation === \"vertical\") {\n    return /* @__PURE__ */ jsx(\n      ScrollAreaScrollbarY,\n      {\n        ...commonProps,\n        ref: forwardedRef,\n        onThumbPositionChange: () => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollTop;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n          }\n        },\n        onWheelScroll: (scrollPos) => {\n          if (context.viewport)\n            context.viewport.scrollTop = scrollPos;\n        },\n        onDragScroll: (pointerPos) => {\n          if (context.viewport)\n            context.viewport.scrollTop = getScrollPosition(pointerPos);\n        }\n      }\n    );\n  }\n  return null;\n});\n\nexport { ScrollAreaScrollbarVisible };\n//# sourceMappingURL=ScrollAreaScrollbarVisible.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { useResizeObserver } from '../use-resize-observer.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\n\nconst ScrollAreaScrollbarAuto = forwardRef(\n  (props, ref) => {\n    const context = useScrollAreaContext();\n    const { forceMount, ...scrollbarProps } = props;\n    const [visible, setVisible] = useState(false);\n    const isHorizontal = props.orientation === \"horizontal\";\n    const handleResize = useDebouncedCallback(() => {\n      if (context.viewport) {\n        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n        const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n        setVisible(isHorizontal ? isOverflowX : isOverflowY);\n      }\n    }, 10);\n    useResizeObserver(context.viewport, handleResize);\n    useResizeObserver(context.content, handleResize);\n    if (forceMount || visible) {\n      return /* @__PURE__ */ jsx(\n        ScrollAreaScrollbarVisible,\n        {\n          \"data-state\": visible ? \"visible\" : \"hidden\",\n          ...scrollbarProps,\n          ref\n        }\n      );\n    }\n    return null;\n  }\n);\n\nexport { ScrollAreaScrollbarAuto };\n//# sourceMappingURL=ScrollAreaScrollbarAuto.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useEffect } from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { ScrollAreaScrollbarAuto } from './ScrollAreaScrollbarAuto.mjs';\n\nconst ScrollAreaScrollbarHover = forwardRef(\n  (props, ref) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const [visible, setVisible] = useState(false);\n    useEffect(() => {\n      const { scrollArea } = context;\n      let hideTimer = 0;\n      if (scrollArea) {\n        const handlePointerEnter = () => {\n          window.clearTimeout(hideTimer);\n          setVisible(true);\n        };\n        const handlePointerLeave = () => {\n          hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n        };\n        scrollArea.addEventListener(\"pointerenter\", handlePointerEnter);\n        scrollArea.addEventListener(\"pointerleave\", handlePointerLeave);\n        return () => {\n          window.clearTimeout(hideTimer);\n          scrollArea.removeEventListener(\"pointerenter\", handlePointerEnter);\n          scrollArea.removeEventListener(\"pointerleave\", handlePointerLeave);\n        };\n      }\n      return void 0;\n    }, [context.scrollArea, context.scrollHideDelay]);\n    if (forceMount || visible) {\n      return /* @__PURE__ */ jsx(\n        ScrollAreaScrollbarAuto,\n        {\n          \"data-state\": visible ? \"visible\" : \"hidden\",\n          ...scrollbarProps,\n          ref\n        }\n      );\n    }\n    return null;\n  }\n);\n\nexport { ScrollAreaScrollbarHover };\n//# sourceMappingURL=ScrollAreaScrollbarHover.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useEffect } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\n\nconst ScrollAreaScrollbarScroll = forwardRef(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === \"horizontal\";\n    const [state, setState] = useState(\"hidden\");\n    const debounceScrollEnd = useDebouncedCallback(() => setState(\"idle\"), 100);\n    useEffect(() => {\n      if (state === \"idle\") {\n        const hideTimer = window.setTimeout(() => setState(\"hidden\"), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n      return void 0;\n    }, [state, context.scrollHideDelay]);\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState(\"scrolling\");\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener(\"scroll\", handleScroll);\n        return () => viewport.removeEventListener(\"scroll\", handleScroll);\n      }\n      return void 0;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n    if (forceMount || state !== \"hidden\") {\n      return /* @__PURE__ */ jsx(\n        ScrollAreaScrollbarVisible,\n        {\n          \"data-state\": state === \"hidden\" ? \"hidden\" : \"visible\",\n          ...scrollbarProps,\n          ref: red,\n          onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState(\"interacting\")),\n          onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState(\"idle\"))\n        }\n      );\n    }\n    return null;\n  }\n);\n\nexport { ScrollAreaScrollbarScroll };\n//# sourceMappingURL=ScrollAreaScrollbarScroll.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useEffect } from 'react';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { ScrollAreaScrollbarAuto } from './ScrollAreaScrollbarAuto.mjs';\nimport { ScrollAreaScrollbarHover } from './ScrollAreaScrollbarHover.mjs';\nimport { ScrollAreaScrollbarScroll } from './ScrollAreaScrollbarScroll.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\n\nconst ScrollAreaScrollbar = forwardRef(\n  (props, forwardedRef) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;\n    const isHorizontal = props.orientation === \"horizontal\";\n    useEffect(() => {\n      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n      return () => {\n        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n      };\n    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n    return context.type === \"hover\" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === \"scroll\" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === \"auto\" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === \"always\" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;\n  }\n);\n\nexport { ScrollAreaScrollbar };\n//# sourceMappingURL=ScrollAreaScrollbar.mjs.map\n","'use client';\nfunction addUnlinkedScrollListener(node, handler = () => {\n}) {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll)\n      handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n}\n\nexport { addUnlinkedScrollListener };\n//# sourceMappingURL=add-unlinked-scroll-listener.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { useMergedRef, useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { useScrollbarContext } from '../ScrollAreaScrollbar/Scrollbar.context.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { addUnlinkedScrollListener } from '../utils/add-unlinked-scroll-listener.mjs';\n\nconst Thumb = forwardRef((props, forwardedRef) => {\n  const { style, ...others } = props;\n  const scrollAreaContext = useScrollAreaContext();\n  const scrollbarContext = useScrollbarContext();\n  const { onThumbPositionChange } = scrollbarContext;\n  const composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node));\n  const removeUnlinkedScrollListenerRef = useRef();\n  const debounceScrollEnd = useDebouncedCallback(() => {\n    if (removeUnlinkedScrollListenerRef.current) {\n      removeUnlinkedScrollListenerRef.current();\n      removeUnlinkedScrollListenerRef.current = void 0;\n    }\n  }, 100);\n  useEffect(() => {\n    const { viewport } = scrollAreaContext;\n    if (viewport) {\n      const handleScroll = () => {\n        debounceScrollEnd();\n        if (!removeUnlinkedScrollListenerRef.current) {\n          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n          removeUnlinkedScrollListenerRef.current = listener;\n          onThumbPositionChange();\n        }\n      };\n      onThumbPositionChange();\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n    return void 0;\n  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n  return /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      \"data-state\": scrollbarContext.hasThumb ? \"visible\" : \"hidden\",\n      ...others,\n      ref: composedRef,\n      style: {\n        width: \"var(--sa-thumb-width)\",\n        height: \"var(--sa-thumb-height)\",\n        ...style\n      },\n      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {\n        const thumb = event.target;\n        const thumbRect = thumb.getBoundingClientRect();\n        const x = event.clientX - thumbRect.left;\n        const y = event.clientY - thumbRect.top;\n        scrollbarContext.onThumbPointerDown({ x, y });\n      }),\n      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)\n    }\n  );\n});\nconst ScrollAreaThumb = forwardRef(\n  (props, forwardedRef) => {\n    const { forceMount, ...thumbProps } = props;\n    const scrollbarContext = useScrollbarContext();\n    if (forceMount || scrollbarContext.hasThumb) {\n      return /* @__PURE__ */ jsx(Thumb, { ref: forwardedRef, ...thumbProps });\n    }\n    return null;\n  }\n);\n\nexport { ScrollAreaThumb, Thumb };\n//# sourceMappingURL=ScrollAreaThumb.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport { Box } from '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\n\nconst ScrollAreaViewport = forwardRef(\n  ({ children, style, ...others }, ref) => {\n    const ctx = useScrollAreaContext();\n    const rootRef = useMergedRef(ref, ctx.onViewportChange);\n    return /* @__PURE__ */ jsx(\n      Box,\n      {\n        ...others,\n        ref: rootRef,\n        style: {\n          overflowX: ctx.scrollbarXEnabled ? \"scroll\" : \"hidden\",\n          overflowY: ctx.scrollbarYEnabled ? \"scroll\" : \"hidden\",\n          ...style\n        },\n        children: /* @__PURE__ */ jsx(\"div\", { style: { minWidth: \"100%\", display: \"table\" }, ref: ctx.onContentChange, children })\n      }\n    );\n  }\n);\nScrollAreaViewport.displayName = \"@mantine/core/ScrollAreaViewport\";\n\nexport { ScrollAreaViewport };\n//# sourceMappingURL=ScrollAreaViewport.mjs.map\n","'use client';\nvar classes = {\"root\":\"m_d57069b5\",\"viewport\":\"m_c0783ff9\",\"viewportInner\":\"m_f8f631dd\",\"scrollbar\":\"m_c44ba933\",\"thumb\":\"m_d8b5e363\",\"corner\":\"m_21657268\"};\n\nexport { classes as default };\n//# sourceMappingURL=ScrollArea.module.css.mjs.map\n","'use client';\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { useState } from 'react';\nimport { rem } from '../../core/utils/units-converters/rem.mjs';\nimport '@mantine/hooks';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport { Box } from '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { ScrollAreaCorner } from './ScrollAreaCorner/ScrollAreaCorner.mjs';\nimport { ScrollAreaRoot } from './ScrollAreaRoot/ScrollAreaRoot.mjs';\nimport { ScrollAreaScrollbar } from './ScrollAreaScrollbar/ScrollAreaScrollbar.mjs';\nimport { ScrollAreaThumb } from './ScrollAreaThumb/ScrollAreaThumb.mjs';\nimport { ScrollAreaViewport } from './ScrollAreaViewport/ScrollAreaViewport.mjs';\nimport classes from './ScrollArea.module.css.mjs';\n\nconst defaultProps = {\n  scrollHideDelay: 1e3,\n  type: \"hover\",\n  scrollbars: \"xy\"\n};\nconst varsResolver = createVarsResolver((_, { scrollbarSize }) => ({\n  root: {\n    \"--scrollarea-scrollbar-size\": rem(scrollbarSize)\n  }\n}));\nconst ScrollArea = factory((_props, ref) => {\n  const props = useProps(\"ScrollArea\", defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    scrollbarSize,\n    vars,\n    type,\n    scrollHideDelay,\n    viewportProps,\n    viewportRef,\n    onScrollPositionChange,\n    children,\n    offsetScrollbars,\n    scrollbars,\n    ...others\n  } = props;\n  const [scrollbarHovered, setScrollbarHovered] = useState(false);\n  const getStyles = useStyles({\n    name: \"ScrollArea\",\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver\n  });\n  return /* @__PURE__ */ jsxs(\n    ScrollAreaRoot,\n    {\n      type: type === \"never\" ? \"always\" : type,\n      scrollHideDelay,\n      ref,\n      scrollbars,\n      ...getStyles(\"root\"),\n      ...others,\n      children: [\n        /* @__PURE__ */ jsx(\n          ScrollAreaViewport,\n          {\n            ...viewportProps,\n            ...getStyles(\"viewport\", { style: viewportProps?.style }),\n            ref: viewportRef,\n            \"data-offset-scrollbars\": offsetScrollbars === true ? \"xy\" : offsetScrollbars || void 0,\n            \"data-scrollbars\": scrollbars || void 0,\n            onScroll: (e) => {\n              viewportProps?.onScroll?.(e);\n              onScrollPositionChange?.({ x: e.currentTarget.scrollLeft, y: e.currentTarget.scrollTop });\n            },\n            children\n          }\n        ),\n        (scrollbars === \"xy\" || scrollbars === \"x\") && /* @__PURE__ */ jsx(\n          ScrollAreaScrollbar,\n          {\n            ...getStyles(\"scrollbar\"),\n            orientation: \"horizontal\",\n            \"data-hidden\": type === \"never\" || void 0,\n            forceMount: true,\n            onMouseEnter: () => setScrollbarHovered(true),\n            onMouseLeave: () => setScrollbarHovered(false),\n            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles(\"thumb\") })\n          }\n        ),\n        (scrollbars === \"xy\" || scrollbars === \"y\") && /* @__PURE__ */ jsx(\n          ScrollAreaScrollbar,\n          {\n            ...getStyles(\"scrollbar\"),\n            orientation: \"vertical\",\n            \"data-hidden\": type === \"never\" || void 0,\n            forceMount: true,\n            onMouseEnter: () => setScrollbarHovered(true),\n            onMouseLeave: () => setScrollbarHovered(false),\n            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles(\"thumb\") })\n          }\n        ),\n        /* @__PURE__ */ jsx(\n          ScrollAreaCorner,\n          {\n            ...getStyles(\"corner\"),\n            \"data-hovered\": scrollbarHovered || void 0,\n            \"data-hidden\": type === \"never\" || void 0\n          }\n        )\n      ]\n    }\n  );\n});\nScrollArea.displayName = \"@mantine/core/ScrollArea\";\nconst ScrollAreaAutosize = factory((props, ref) => {\n  const {\n    children,\n    classNames,\n    styles,\n    scrollbarSize,\n    scrollHideDelay,\n    type,\n    dir,\n    offsetScrollbars,\n    viewportRef,\n    onScrollPositionChange,\n    unstyled,\n    variant,\n    viewportProps,\n    scrollbars,\n    style,\n    vars,\n    ...others\n  } = useProps(\"ScrollAreaAutosize\", defaultProps, props);\n  return /* @__PURE__ */ jsx(Box, { ...others, ref, style: [{ display: \"flex\", overflow: \"auto\" }, style], children: /* @__PURE__ */ jsx(Box, { style: { display: \"flex\", flexDirection: \"column\", flex: 1 }, children: /* @__PURE__ */ jsx(\n    ScrollArea,\n    {\n      classNames,\n      styles,\n      scrollHideDelay,\n      scrollbarSize,\n      type,\n      dir,\n      offsetScrollbars,\n      viewportRef,\n      onScrollPositionChange,\n      unstyled,\n      variant,\n      viewportProps,\n      vars,\n      scrollbars,\n      children\n    }\n  ) }) });\n});\nScrollArea.classes = classes;\nScrollAreaAutosize.displayName = \"@mantine/core/ScrollAreaAutosize\";\nScrollAreaAutosize.classes = classes;\nScrollArea.Autosize = ScrollAreaAutosize;\n\nexport { ScrollArea, ScrollAreaAutosize };\n//# sourceMappingURL=ScrollArea.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { createContext, useContext, useState } from 'react';\nimport { useIsomorphicEffect } from '@mantine/hooks';\n\nconst DirectionContext = createContext({\n  dir: \"ltr\",\n  toggleDirection: () => {\n  },\n  setDirection: () => {\n  }\n});\nfunction useDirection() {\n  return useContext(DirectionContext);\n}\nfunction DirectionProvider({\n  children,\n  initialDirection = \"ltr\",\n  detectDirection = true\n}) {\n  const [dir, setDir] = useState(initialDirection);\n  const setDirection = (direction) => {\n    setDir(direction);\n    document.documentElement.setAttribute(\"dir\", direction);\n  };\n  const toggleDirection = () => setDirection(dir === \"ltr\" ? \"rtl\" : \"ltr\");\n  useIsomorphicEffect(() => {\n    if (detectDirection) {\n      const direction = document.documentElement.getAttribute(\"dir\");\n      if (direction === \"rtl\" || direction === \"ltr\") {\n        setDirection(direction);\n      }\n    }\n  }, []);\n  return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: { dir, toggleDirection, setDirection }, children });\n}\n\nexport { DirectionContext, DirectionProvider, useDirection };\n//# sourceMappingURL=DirectionProvider.mjs.map\n","'use client';\nimport { jsx } from 'react/jsx-runtime';\nimport { createContext, useContext } from 'react';\n\nfunction createSafeContext(errorMessage) {\n  const Context = createContext(null);\n  const useSafeContext = () => {\n    const ctx = useContext(Context);\n    if (ctx === null) {\n      throw new Error(errorMessage);\n    }\n    return ctx;\n  };\n  const Provider = ({ children, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children });\n  return [Provider, useSafeContext];\n}\n\nexport { createSafeContext };\n//# sourceMappingURL=create-safe-context.mjs.map\n","'use client';\nimport { Fragment } from 'react';\n\nfunction isElement(value) {\n  if (Array.isArray(value) || value === null) {\n    return false;\n  }\n  if (typeof value === \"object\") {\n    if (value.type === Fragment) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport { isElement };\n//# sourceMappingURL=is-element.mjs.map\n","'use client';\nimport { useCallback } from 'react';\n\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (typeof ref === \"object\" && ref !== null && \"current\" in ref) {\n    ref.current = value;\n  }\n}\nfunction mergeRefs(...refs) {\n  return (node) => {\n    refs.forEach((ref) => assignRef(ref, node));\n  };\n}\nfunction useMergedRef(...refs) {\n  return useCallback(mergeRefs(...refs), refs);\n}\n\nexport { assignRef, mergeRefs, useMergedRef };\n//# sourceMappingURL=use-merged-ref.mjs.map\n"],"names":["min","Math","max","round","floor","createCoords","v","x","y","oppositeSideMap","left","right","bottom","top","oppositeAlignmentMap","start","end","floating_ui_utils_evaluate","value","param","floating_ui_utils_getSide","placement","split","floating_ui_utils_getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","includes","floating_ui_utils_getOppositeAlignmentPlacement","replace","alignment","getOppositePlacement","side","getPaddingObject","padding","rectToClientRect","rect","width","height","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","computePosition","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","length","name","fn","nextX","nextY","data","reset","initialPlacement","elements","detectOverflow","state","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","getBoundingRect","minX","map","minY","maxX","maxY","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","getCssDimensions","css","floating_ui_utils_dom","Dx","parseFloat","hasOffset","Re","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","kK","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","win","Jj","Pf","visualViewport","offsetLeft","offsetTop","includeScale","isFixedStrategy","isFixed","clientRect","scale","visualOffsets","shouldAddVisualOffsets","floatingOffsetParent","offsetWin","currentWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","topLayerSelectors","isTopLayer","some","selector","matches","e","getWindowScrollBarX","tF","Lw","scrollLeft","getClientRectFromClippingAncestor","clippingAncestor","getViewportRect","html","clientWidth","clientHeight","visualViewportBased","getDocumentRect","scroll","body","ownerDocument","scrollWidth","scrollHeight","scrollTop","direction","getInnerBoundingClientRect","isStaticPositioned","position","getTrueOffsetParent","polyfill","svgOffsetParent","Ow","Py","Ze","hT","gQ","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","getRectRelativeToOffsetParent","isOffsetParentAnElement","documentElement","offsets","wk","ao","offsetRect","topLayer","clippingAncestors","getClippingElementAncestors","cache","cachedResult","get","result","Kx","el","currentContainingBlockComputedStyle","elementIsFixed","currentNode","computedStyle","currentNodeIsContaining","hasFixedPositionAncestor","stopNode","parentNode","ancestor","set","_c","concat","firstClippingAncestor","clippingRect","reduce","accRect","getClientRects","Array","from","autoUpdate","update","frameId","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","observeMove","onMove","timeoutId","io","root","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","observe","reobserveFrame","resizeObserver","firstEntry","target","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","removeEventListener","floating_ui_dom_offset","_middlewareData$offse","_middlewareData$arrow","diffCoords","offset","arrow","alignmentOffset","floating_ui_dom_shift","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","overflow","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","floating_ui_dom_flip","_middlewareData$flip","_middlewareData$flip2","_overflowsData$filter","_overflowsData$map$so","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","isBasePlacement","getExpandedPlacements","oppositePlacement","push","getOppositeAxisPlacements","list","getSideList","isStart","lr","rl","placements","overflows","overflowsData","flip","sides","floating_ui_utils_getAlignmentSides","mainAlignmentSide","every","nextIndex","index","nextPlacement","resetPlacement","d","sort","a","b","acc","floating_ui_dom_size","heightSide","widthSide","apply","isYAxis","overflowAvailableHeight","overflowAvailableWidth","noShift","shift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","floating_ui_dom_arrow","arrowDimensions","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","largestPossiblePadding","minPadding","maxPadding","center","shouldAddOffset","centerOffset","floating_ui_dom_inline","nativeClientRects","clientRects","getRectsByLine","sortedRects","slice","groups","prevRect","fallback","resetRects","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","floating_ui_dom_limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","floating_ui_dom_computePosition","Map","mergedOptions","platformWithCache","hasOwnProperty","call","current","_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__","x7","document","react__WEBPACK_IMPORTED_MODULE_0__","useLayoutEffect","useEffect","deepEqual","keys","toString","isArray","Object","key","$$typeof","getDPR","window","defaultView","devicePixelRatio","roundByDPR","dpr","useLatestRef","ref","useRef","useFloating","externalReference","externalFloating","transform","whileElementsMounted","open","setData","useState","isPositioned","latestMiddleware","setLatestMiddleware","_reference","_setReference","_floating","_setFloating","setReference","useCallback","node","referenceRef","setFloating","floatingRef","floatingEl","dataRef","hasWhileElementsMounted","whileElementsMountedRef","platformRef","oo","then","fullData","isMountedRef","react_dom__WEBPACK_IMPORTED_MODULE_1__","flushSync","refs","useMemo","floatingStyles","initialStyles","willChange","floating_ui_react_utils_activeElement","doc","activeElement","_activeElement","shadowRoot","floating_ui_react_utils_contains","parent","child","rootNode","getRootNode","contains","Zq","next","host","floating_ui_react_utils_getPlatform","uaData","navigator","userAgentData","floating_ui_react_utils_getUserAgent","brands","brand","version","join","userAgent","isAndroid","re","test","floating_ui_react_utils_isMouseLikePointerType","pointerType","strict","values","undefined","floating_ui_react_utils_getDocument","isEventTargetWithin","event","composedPath","floating_ui_react_utils_getTarget","SafeReact","react_namespaceObject","useSafeInsertionEffect","useInsertionEffect","useEffectEvent","callback","react","_len","arguments","args","_key","serverHandoffComplete","count","genId","random","useId","useReactId","id","setId","FloatingNodeContext","createContext","FloatingTreeContext","useFloatingParentNodeId","_React$useContext","useContext","useFloatingTree","createAttribute","safePolygonIdentifier","getDelay","prop","useHover","context","props","onOpenChange","events","domReference","enabled","delay","handleClose","mouseOnly","restMs","move","tree","parentId","handleCloseRef","delayRef","pointerTypeRef","timeoutRef","handlerRef","restTimeoutRef","blockMouseMoveRef","performedPointerEventsMutationRef","unbindMouseMoveRef","isHoverOpen","_dataRef$current$open","type","openEvent","on","off","onLeave","closeWithDelay","runElseBranch","reason","closeDelay","cleanupMouseMoveHandler","clearPointerEvents","style","pointerEvents","removeAttribute","onScrollMouseLeave","onMouseEnter","once","onMouseLeave","isClickLikeOpenEvent","openDelay","clientX","clientY","onClose","handler","relatedTarget","_handleCloseRef$curre","_tree$nodesRef$curren","__options","blockPointerEvents","setAttribute","parentFloating","nodesRef","setPointerRef","onPointerDown","onPointerEnter","onMouseMove","handleMouseMove","nativeEvent","NOOP","FloatingDelayGroupContext","initialDelay","timeoutMs","currentId","setCurrentId","setState","isInstantPhase","useDelayGroupContext","FloatingDelayGroup","children","useReducer","prev","initialCurrentIdRef","createElement","Provider","useDelayGroup","floatingId","optionId","groupContext","close","unset","timeout","getChildren","nodes","allChildren","_node$context","currentChildren","_currentChildren","n","_node$context2","bubbleHandlerKeys","pointerdown","mousedown","click","captureHandlerKeys","normalizeProp","normalizable","_normalizable$escapeK","_normalizable$outside","escapeKey","outsidePress","useDismiss","nodeId","unstable_outsidePress","outsidePressEvent","referencePress","referencePressEvent","bubbles","capture","outsidePressFn","insideReactTreeRef","endedOrStartedInsideRef","escapeKeyBubbles","outsidePressBubbles","escapeKeyCapture","outsidePressCapture","closeOnEscapeKeyDown","stopPropagation","shouldDismiss","_child$context","__escapeKeyBubbles","isReactEvent","closeOnEscapeKeyDownCapture","_getTarget2","_getTarget","closeOnPressOutside","insideReactTree","endedOrStartedInside","inertSelector","markers","querySelectorAll","targetRootAncestor","nextParent","marker","canScrollX","canScrollY","xCond","offsetX","offsetY","targetIsInsideChildren","_child$context2","__outsidePressBubbles","closeOnPressOutsideCapture","_getTarget4","_getTarget3","onScroll","_doc$defaultView","onKeyDown","onMouseDown","onMouseUp","_options$elements","unstable_onOpenChange","_domReference","setDomReference","positionReference","_setPositionReference","optionDomReference","domReferenceRef","floating_ui_react_dom","YF","nested","emit","createPubSub","_map$get","listener","_map$get2","l","setPositionReference","computedPositionReference","useFocus","visibleOnly","blockFocusRef","keyboardModalityRef","onBlur","pressure","detail","onFocus","floating_ui_react_utils_isSafari","vendor","toLowerCase","startsWith","maxTouchPoints","Error","movedToFocusGuard","hasAttribute","getAttribute","activeEl","ACTIVE_KEY","SELECTED_KEY","mergeProps","userProps","propsList","elementKey","isItem","domUserProps","_","__","validProps","tabIndex","propsOrGetProps","indexOf","has","val","useInteractions","deps","getReferenceProps","getFloatingProps","getItemProps","item","componentRoleToAriaRoleMap","useRole","_componentRoleToAriaR","role","ariaRole","referenceId","isNested","floatingProps","active","selected","commonProps","getNodeName","nodeName","getWindow","_node$ownerDocument","isNode","Node","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isContainingBlock","webkit","isWebKit","perspective","containerType","backdropFilter","contain","getContainingBlock","getParentNode","isLastTraversableNode","CSS","supports","getNodeScroll","pageXOffset","pageYOffset","assignedSlot","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","getNearestOverflowAncestor","isBody","horizontalSide","arrowY","arrowOffset","arrowPosition","verticalSide","arrowX","dir","radiusByFloatingSide","FloatingArrow","forwardRef","arrowSize","arrowRadius","visible","others","DirectionProvider","gm","jsx_runtime","jsx","getArrowPositionStyles","baseStyles","rem","h","arrowPlacement","borderLeftColor","borderBottomColor","borderRightColor","borderTopColor","displayName","getFloatingPosition","flippedPosition","useFloatingAutoUpdate","opened","positionDependencies","delayedUpdate","setDelayedUpdate","_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__","Me","_mantine_hooks__WEBPACK_IMPORTED_MODULE_2__","c","classes","defaultProps","preventGrowOverflow","gap","align","justify","wrap","varsResolver","create_vars_resolver","Z","grow","childWidth","get_size","bG","Group","factory","_props","use_props","w","classNames","className","styles","unstyled","vars","variant","__size","mod","filteredChildren","Children","toArray","childrenCount","resolvedGap","getStyles","use_styles","stylesCtx","Box","size","Portal","mounted","setMounted","nodeRef","use_isomorphic_effect","Y","querySelector","createPortalNode","classList","add","assign","use_merged_ref","kR","appendChild","removeChild","react_dom","createPortal","Fragment","OptionalPortal","withinPortal","ScrollAreaProvider","useScrollAreaContext","create_safe_context","R","useCallbackRef","callbackRef","useResizeObserver","onResize","handleResize","rAF","Corner","ctx","setWidth","setHeight","hasSize","scrollbarX","onCornerHeightChange","scrollbarY","onCornerWidthChange","ScrollAreaCorner","hasBothScrollbarsVisible","hasCorner","scrollHideDelay","ScrollAreaRoot","scrollbars","scrollArea","setScrollArea","viewport","setViewport","content","setContent","setScrollbarX","setScrollbarY","cornerWidth","setCornerWidth","cornerHeight","setCornerHeight","scrollbarXEnabled","setScrollbarXEnabled","scrollbarYEnabled","setScrollbarYEnabled","rootRef","Yx","onViewportChange","onContentChange","onScrollbarXChange","onScrollbarXEnabledChange","onScrollbarYChange","onScrollbarYEnabledChange","__vars","useDebouncedCallback","handleCallback","debounceTimerRef","getThumbRatio","viewportSize","contentSize","isNaN","getThumbSize","sizes","scrollbarPadding","scrollbar","paddingStart","paddingEnd","linearScale","input","output","getThumbOffsetFromScroll","scrollPos","thumbSizePx","maxScrollPos","scrollWithoutMomentum","clamp","interpolate","toInt","parseInt","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","defaultPrevented","ScrollbarProvider","useScrollbarContext","Scrollbar","forwardedRef","hasThumb","onThumbChange","onThumbPointerUp","onThumbPointerDown","onThumbPositionChange","onDragScroll","onWheelScroll","scrollbarProps","setScrollbar","composeRefs","rectRef","prevWebkitUserSelectRef","handleWheelScroll","handleThumbPositionChange","handleDragScroll","handleWheel","button","setPointerCapture","pointerId","webkitUserSelect","onPointerMove","onPointerUp","hasPointerCapture","releasePointerCapture","ScrollAreaScrollbarX","onSizesChange","setComputedStyle","pointerPos","deltaX","preventDefault","paddingRight","ScrollAreaScrollbarY","deltaY","paddingBottom","ScrollAreaScrollbarVisible","orientation","thumbRef","pointerOffsetRef","setSizes","thumbRatio","thumb","getScrollPosition","getScrollPositionFromPointer","pointerOffset","minPointerPos","maxPointerPos","ScrollAreaScrollbarAuto","forceMount","setVisible","isHorizontal","isOverflowX","isOverflowY","ScrollAreaScrollbarHover","hideTimer","handlePointerEnter","handlePointerLeave","ScrollAreaScrollbarScroll","red","debounceScrollEnd","scrollDirection","prevScrollPos","handleScroll","onPointerLeave","ScrollAreaScrollbar","Thumb","scrollAreaContext","scrollbarContext","composedRef","removeUnlinkedScrollListenerRef","addUnlinkedScrollListener","prevPosition","loop","isHorizontalScroll","isVerticalScroll","onPointerDownCapture","thumbRect","ScrollAreaThumb","thumbProps","ScrollAreaViewport","minWidth","ScrollArea_defaultProps","scrollbarSize","ScrollArea","viewportProps","viewportRef","onScrollPositionChange","offsetScrollbars","scrollbarHovered","setScrollbarHovered","jsxs","currentTarget","ScrollAreaAutosize","flexDirection","flex","Autosize","DirectionContext","react__WEBPACK_IMPORTED_MODULE_1__","toggleDirection","setDirection","useDirection","createSafeContext","errorMessage","Context","react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__","assignRef","mergeRefs","useMergedRef"],"sourceRoot":""}